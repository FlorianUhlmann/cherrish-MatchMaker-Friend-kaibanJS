# Recording and Transcription Flow Update Plan

## Objective
Converge the composer UI/UX on the latest voice-recording workflow: the mic control toggles between a single icon-rich Mic button and, only while recording, a pair of equal-width OK/Abort buttons with a loading spinner; the visualizer is hidden until recording starts, then appears to the left of the controls; the timer counts elapsed seconds as `X/120s`, turns red past 110s, auto-selects OK when 120s is reached, and the recorded audio submits to Whisper; transcripts land only in the textarea for user review and remain there even if another recording is started; the recorded text also appends to any existing composer content; and the agent flow waits until the user presses Send rather than reacting to Whisper results immediately.

## Steps
1. **State & timer bookkeeping** – confirm `isRecording`, `recordSeconds`, `isVisualizerVisible`, and any loading/feedback flags are wired so the timer/meter only render during an active recording, the timer increments until 120 seconds, and hitting 120 triggers the same finalization logic as an OK tap.
2. **Composer markup/layout** – refactor `app/page.tsx` to right-align the controls (`Mic`/`OK`/`Abort` + `Send`), render the visualizer/timer block to their left only while recording, ensure the Mic button includes both the icon and the loading spinner when active, and that the OK/Abort pair appear in the same footprint (equal width) while recording.
3. **Timer logic & warning** – compute `${recordSeconds}/120s`, start the counter once recording begins, add a `timer--warning` class (red styling) when `recordSeconds >= 110`, and trigger the stop/send routine automatically when the counter reaches 120 seconds. This auto-trigger must mirror the user clicking OK: the recorder stops, the captured audio is forwarded to Whisper, the transcript returns to the composer, and the UI swaps back from the OK/Abort pair to the single Mic button just like a manual confirmation does.
4. **Sticky composer behavior** – keep Whisper transcripts out of the chat until the user hits Send, avoid placeholder/fallback bubbles, and append new transcripts with a helper that preserves existing typed content so multiple recordings never override the composer field.
5. **Recording lifecycle transitions** – ensure the Mic button launches recording and swaps to OK/Abort during capture, OK confirms and posts the audio to Whisper, Abort cancels/resets the recorder and returns to the single Mic button, and both transitions keep the send button on the right unaffected.
6. **Defer agent execution** – when Whisper returns text, place it into the composer only, let the user edit and send, and keep `applyServerResponse` focused on session metadata so the agent pipeline only runs when `handleSend` is explicitly called.
7. **CSS & spinner updates** – adjust `.composer-actions`, `.mic`, `.mic-actions`, `.mic-meter`, `.timer`, and spinner classes in `app/globals.css` so the visualizer sits left of the controls, the spinner animates on the mic button during recording/transcription, the timer changes color past 110s, and button sizing matches the new layout plus the mic icon.
8. **Testing & lint/build** – run `npm run lint` and `npm run build` inside a tmux session as required, then manually verify that the visualizer and timer remain hidden until recording, the control swap/auto-stop behavior works, Whisper transcripts appear in the chat for editing, and the agent only runs once the user sends the message.

## Risks & Notes
- Need to ensure the existing recording timeout/cleanup still works when aborting and on auto-stop at 120 seconds.
- Spinner animation & visualizer should remain responsive to live voice input without blocking composer send logic.
- Double-check that the send-button state doesn’t change until the transcript is reviewed; the agent should operate only on user-initiated sends.
